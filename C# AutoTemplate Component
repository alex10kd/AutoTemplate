using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using Grasshopper.Kernel.Special;

public class Script_Instance : GH_ScriptInstance
{
    private void RunScript(double size, bool update, ref object A)
    {
        // Get the current Grasshopper document
        GH_Document doc = this.Component.OnPingDocument();
        if (doc == null)
        {
            Print("Could not access Grasshopper document");
            return;
        }

        List<string> result = new List<string>();

        // Get all groups in the document
        var groups = doc.Objects.OfType<GH_Group>().ToList();

        if (groups.Count == 0)
        {
            Print("No groups found in the document");
            A = "No groups found";
            return;
        }

        // Get existing scribbles that were created by this script
        var existingScribbles = doc.Objects.OfType<GH_Scribble>().ToList();

        foreach (GH_Group group in groups)
        {
            string groupName = group.NickName;
            if (string.IsNullOrEmpty(groupName))
                groupName = "_";

            // Skip groups that start with //
            if (groupName.StartsWith("//"))
            {
                result.Add($"Skipped group '{groupName}' (starts with //)");
                continue;
            }

            // Process group name and apply color coding
            string processedName = ProcessGroupName(groupName);
            ApplyGroupColor(group, groupName);
            
            // Check if scribble already exists for this specific group
            var existingScribble = FindExistingScribbleInGroup(existingScribbles, group, processedName);

            if (existingScribble != null)
            {
                if (update)
                {
                    // Update existing scribble but keep its position
                    UpdateScribble(existingScribble, group, size, processedName);
                    result.Add($"Updated scribble for group '{groupName}' -> '{processedName}' (kept position)");
                }
                else
                {
                    result.Add($"Scribble already exists for group '{groupName}' -> '{processedName}' (set update=true to modify)");
                }
            }
            else
            {
                // Create new scribble only if update is true
                if (update)
                {
                    bool success = CreateScribble(doc, group, processedName, size);
                    if (success)
                    {
                        result.Add($"Created new scribble for group '{groupName}' -> '{processedName}'");
                    }
                    else
                    {
                        result.Add($"Failed to create scribble for group '{groupName}' -> '{processedName}'");
                    }
                }
                else
                {
                    result.Add($"Would create scribble for group '{groupName}' -> '{processedName}' (set update=true to create)");
                }
            }
        }

        if (update)
        {
            doc.NewSolution(false);
        }

        A = result;
    }

    private string ProcessGroupName(string groupName)
    {
        // Split the group name into words
        string[] words = groupName.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        
        if (words.Length == 0)
            return groupName;

        // Check if first word is In, Op, Out, or Vis (case insensitive)
        string firstWord = words[0].ToLower();
        if (firstWord == "in" || firstWord == "op" || firstWord == "out" || firstWord == "vis"|| firstWord == "get"|| firstWord == "draw")
        {
            // Return the remaining words joined together
            if (words.Length > 1)
            {
                return string.Join(" ", words.Skip(1));
            }
            else
            {
                // If only one word and it matches, return empty or original
                return "Group";
            }
        }

        // Return original name if first word doesn't match
        return groupName;
    }

    private void ApplyGroupColor(GH_Group group, string groupName)
    {
        // Split the group name into words
        string[] words = groupName.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        
        if (words.Length == 0)
            return;

        // Check if first word matches our color scheme (case insensitive)
        string firstWord = words[0].ToLower();
        Color newColor;
        
        switch (firstWord)
        {
            case "in":
                newColor = Color.FromArgb(209, 142, 142); // Reddish
                break;
            case "out":
                newColor = Color.FromArgb(137, 150, 122); // Greenish
                break;
            case "op":
                newColor = Color.FromArgb(222, 214, 204); // Beige
                break;
            case "vis":
                newColor = Color.FromArgb(185, 227, 235); // Light blue
                break;
              case "get":
                newColor = Color.FromArgb(98,97,145); // Light blue
                break; 
                case "draw":
                newColor = Color.FromArgb(247,96,187); // Light blue
                break; 
            default:
                return; // Keep current color for groups that don't match
        }

        // Apply the color to the group
        group.Colour = newColor;
    }

    private GH_Scribble FindExistingScribbleInGroup(List<GH_Scribble> scribbles, GH_Group group, string processedName)
    {
        // First try to find scribbles that are actual members of this specific group
        var groupObjects = group.Objects();
        var memberScribble = groupObjects.OfType<GH_Scribble>()
            .FirstOrDefault(s => s.Text == processedName);
        
        if (memberScribble != null)
        {
            Print($"Found member scribble '{processedName}' in group '{group.NickName}'");
            return memberScribble;
        }
        
        // DO NOT use spatial fallback - this causes issues with duplicate names
        // Each group should have its own scribble, even if the processed name is the same
        
        Print($"No existing scribble found for '{processedName}' in group '{group.NickName}'");
        return null;
    }

    private bool IsScribbleInGroup(GH_Scribble scribble, System.Drawing.RectangleF groupBounds)
    {
        System.Drawing.RectangleF scribbleBounds = scribble.Attributes.Bounds;
        
        // Check if scribble is within or overlapping the group bounds (with some tolerance)
        return groupBounds.IntersectsWith(scribbleBounds) || 
               (Math.Abs(scribbleBounds.X - groupBounds.X) < 50 &&
                Math.Abs(scribbleBounds.Y - groupBounds.Y) < 50);
    }

    private bool CreateScribble(GH_Document doc, GH_Group group, string processedName, double size)
    {
        try
        {
            Print($"Attempting to create scribble '{processedName}' for group '{group.NickName}'");
            
            System.Drawing.RectangleF groupBounds = group.Attributes.Bounds;
            
            // Position scribble at top-left of group with small offset
            System.Drawing.PointF scribblePosition = new System.Drawing.PointF(
                groupBounds.X + 5, // Small offset from left edge
                groupBounds.Y + 5  // Small offset from top edge
            );

            GH_Scribble scribble = new GH_Scribble();
            scribble.CreateAttributes();
            
            scribble.Text = processedName;
            scribble.Font = new Font("Arial", (float)Math.Max(8, size), FontStyle.Regular);
            
            float scribbleWidth = (float)size * 10;
            float scribbleHeight = (float)size * 2;
            
            // Set bounds for bottom-left justification at top-left of group
            scribble.Attributes.Bounds = new System.Drawing.RectangleF(
                scribblePosition.X, 
                scribblePosition.Y, 
                scribbleWidth, 
                scribbleHeight
            );

            // Set pivot at bottom-left of the scribble for bottom-left justification
            scribble.Attributes.Pivot = new System.Drawing.PointF(
                scribblePosition.X,
                scribblePosition.Y + scribbleHeight
            );

            bool addedToDoc = doc.AddObject(scribble, false);
            Print($"Added scribble to document: {addedToDoc}");
            
            if (addedToDoc)
            {
                group.AddObject(scribble.InstanceGuid);
                Print($"Added scribble '{processedName}' to group '{group.NickName}'");
                return true;
            }
            else
            {
                Print($"Failed to add scribble '{processedName}' to document");
            }
            return false;
        }
        catch (Exception ex)
        {
            Print($"Error creating scribble '{processedName}': {ex.Message}");
            return false;
        }
    }

    private void UpdateScribble(GH_Scribble scribble, GH_Group group, double size, string processedName)
    {
        // Preserve the current position of the existing scribble
        System.Drawing.RectangleF currentBounds = scribble.Attributes.Bounds;
        System.Drawing.PointF currentPivot = scribble.Attributes.Pivot;
        
        // Update text and font but keep position
        scribble.Text = processedName;
        scribble.Font = new Font("Arial", (float)Math.Max(8, size), FontStyle.Regular);
        
        // Calculate new dimensions but keep the current position
        float scribbleWidth = (float)size * 10;
        float scribbleHeight = (float)size * 2;
        
        // Keep the scribble at its current position, only update size
        scribble.Attributes.Bounds = new System.Drawing.RectangleF(
            currentBounds.X,  // Keep current X position
            currentBounds.Y,  // Keep current Y position
            scribbleWidth,    // Update width based on size
            scribbleHeight    // Update height based on size
        );

        // Keep the current pivot point (don't move it)
        scribble.Attributes.Pivot = currentPivot;
    }
}
